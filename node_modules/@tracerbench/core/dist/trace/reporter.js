"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
function findTotalAttrTime(categorized) {
    let totalAggregatedTime = 0;
    Object.keys(categorized).forEach((category) => {
        categorized[category].forEach((result) => {
            totalAggregatedTime += result.attributed;
        });
    });
    return totalAggregatedTime;
}
function filterZeroTotalCats(categorized) {
    return Object.keys(categorized).reduce((map, category) => {
        const filtered = categorized[category].filter((result) => {
            return result.total > 0;
        });
        if (filtered.length > 0) {
            map[category] = filtered;
        }
        return map;
    }, {});
}
class Cell {
    constructor(content) {
        this.content = content;
    }
    pad(size, dir) {
        const { content } = this;
        switch (dir) {
            case 'left':
                this.content = `${new Array(size + 1).join(' ')}${content}`;
                break;
            case 'right':
                this.content = `${content}${new Array(size + 1).join(' ')}`;
                break;
        }
    }
    size() {
        return this.content.length;
    }
    toString() {
        return this.content;
    }
}
class Row {
    constructor(divider) {
        this.divider = divider;
        this.cells = [];
    }
    addCell(content) {
        const cell = new Cell(content);
        this.cells.push(cell);
        return cell;
    }
    size() {
        return this.toString().length;
    }
    cellSizes() {
        return this.cells.map((c) => c.size());
    }
    fit(maxCellSizes) {
        const cellSizes = this.cellSizes();
        if (!this.divider) {
            cellSizes.forEach((size, i) => {
                const amount = maxCellSizes[i] - size;
                this.cells[i].pad(amount, 'right');
            });
        }
    }
    empty() {
        this.addCell('');
    }
    fill(size) {
        const content = new Array(size + 1).join(this.divider);
        this.cells.push(new Cell(content));
    }
    toString() {
        return this.cells.join('');
    }
}
class Table {
    constructor() {
        this.rows = [];
    }
    addRow(divider) {
        const row = new Row(divider);
        this.rows.push(row);
        return row;
    }
    toString() {
        const { rows } = this;
        const maxCellSizes = this.maxCellSizes();
        rows.forEach((row) => {
            if (!row.divider) {
                row.fit(maxCellSizes);
            }
        });
        const rowLength = this.maxRowSize();
        rows.forEach((row) => {
            if (row.divider) {
                row.fill(rowLength);
            }
        });
        return rows.join('\n');
    }
    maxRowSize() {
        let maxRowSize = 0;
        const { rows } = this;
        rows.forEach((row) => {
            const len = row.size();
            if (len > maxRowSize) {
                maxRowSize = len;
            }
        });
        return maxRowSize;
    }
    maxCellSizes() {
        const maxCellSizes = [];
        const { rows } = this;
        rows.forEach((row) => {
            const cellSizes = row.cellSizes();
            cellSizes.forEach((col, i) => {
                if (!maxCellSizes[i] || col > maxCellSizes[i]) {
                    maxCellSizes[i] = col;
                }
            });
        });
        return maxCellSizes;
    }
}
function reporter(categorized) {
    const table = new Table();
    const totalAggregatedTime = findTotalAttrTime(categorized);
    categorized = filterZeroTotalCats(categorized);
    Object.keys(categorized).forEach((category) => {
        const row = table.addRow();
        row.addCell(category);
        row.addCell('Total').pad(2, 'left');
        row.addCell('Attributed').pad(2, 'left');
        row.addCell('% Attributed').pad(2, 'left');
        table.addRow('=');
        let categoryTime = 0;
        const entries = categorized[category];
        const sorted = entries.sort((a, b) => b.attributed - a.attributed);
        sorted.forEach((result) => {
            const stats = table.addRow();
            if (category === utils_1.AUTO_ADD_CAT) {
                stats.addCell(`${result.moduleName}`).pad(2, 'left');
            }
            else {
                stats
                    .addCell(`${result.moduleName} - ${result.functionName}`)
                    .pad(2, 'left');
            }
            stats.addCell(`${toMS(result.total)}ms`).pad(2, 'left');
            stats.addCell(`${toMS(result.attributed)}ms`).pad(2, 'left');
            stats
                .addCell(`${((result.attributed / totalAggregatedTime) * 100).toFixed(2)}%`)
                .pad(2, 'left');
            categoryTime += result.attributed;
        });
        table.addRow('-');
        const subtotal = table.addRow();
        subtotal.addCell('Subtotal');
        subtotal.empty();
        subtotal.addCell(`${toMS(categoryTime)}ms`).pad(2, 'left');
        table.addRow('=');
        table.addRow().empty();
    });
    const totalRow = table.addRow();
    totalRow.addCell('Total');
    totalRow.empty();
    totalRow.addCell(`${toMS(totalAggregatedTime)}`).pad(2, 'left');
    return `${table.toString()} \n\n`;
}
exports.default = reporter;
function round(num) {
    return Math.round(num * 100) / 100;
}
function toMS(num) {
    return round(num / 1000);
}
//# sourceMappingURL=reporter.js.map